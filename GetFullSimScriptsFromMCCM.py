"""
This script automates the process of downloading, preparing, and processing CMS full detector simulation starting from gridpack.

This script depends on the four external files. They are:

1. [ChainDownloadLinkFromMccM_dict.py](ChainDownloadLinkFromMccM_dict.py) - Contains the chain name and the download link from McM.
    1. [CMSSWConfigFile.txt](CMSSWConfigFile.txt) - Contains the list of configuration files you want to generate.
        This file is generated by the script, [GetFullSimScriptsFromMCCM.py](GetFullSimScriptsFromMCCM.py) based on the
        [ChainDownloadLinkFromMccM_dict.py](ChainDownloadLinkFromMccM_dict.py). If you already have the configuration files,
        then just set properly the file CMSWConfigFile.txt. **Note:** you can also change the name of this file using command line
1. [gridpack_lists.py](gridpack_lists.py) - Contains the list of gridpacks you want to generate.

The script performs the following tasks:
1. Download the scripts from the provided URLs.
2. Modify the downloaded scripts.
3. Parse the scripts for CMSSW version and configuration file information.
4. Generate an executable script from the configuration file.
5. Generate a JDL file  and sh for condor submission.
6. Submit the jobs using the generated JDL file.
"""

import os
import subprocess
import logging
import argparse
from urllib.parse import urlparse
from pathlib import Path
from collections import OrderedDict
import datetime

# Setup logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Importing configurations from external files
from utils.ChainDownloadLinkFromMccM_dict import ChainDownloadLinkFromMccM_dict
from utils.condor_script_template import jdl_file_template_part1of2, jdl_file_template_part2of2, ReplacementDict
from utils.gridpack_lists import models


def run_subprocess(command: list, task_description: str) -> subprocess.CompletedProcess:
    """Execute a subprocess command and handle errors."""
    try:
        result = subprocess.run(command, check=True, text=True, capture_output=True)
        logging.info(f'Successfully completed {task_description}: {result.stdout}')
        return result
    except subprocess.CalledProcessError as e:
        logging.error(f'Error during {task_description}: {e.stderr}')
        raise

def url_validator(url: str) -> bool:
    """Validate the URL."""
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False

def download_script(url: str, script_name: str):
    """Download a script from a given URL after validating the URL."""
    if not url_validator(url):
        logging.error(f'Invalid URL: {url}')
        return
    logging.info(f'Downloading {script_name} from {url}')
    run_subprocess(["wget", url, "-O", script_name], f'downloading {script_name}')

def modify_script(script_name: str):
    """Perform modifications on the downloaded script using sed command."""
    script_path = Path(script_name)
    if not script_path.exists():
        logging.error(f'Script not found: {script_name}')
        return
    run_subprocess(["sed", "-i", "/cd \\/afs/s/^/#/", script_name], 'commenting out cd /afs')
    run_subprocess(["sed", "-i", "s/mv ../cp -r ../g", script_name], 'replacing mv with cp -r')
    run_subprocess(["chmod", "+x", script_name], 'making script executable')

def parse_script_for_config(script_name: str, config_file_path: str):
    """Extract CMSSW version and config file information from a script."""
    CMSSWVersion, CMSSW_ConfigFile = None, None
    with open(script_name, 'r') as file:
        for line in file:
            if 'CMSSW' in line and '-r' in line:
                CMSSWVersion = line.split('-r')[1].split('/')[0].strip()
            if '--python_filename' in line:
                CMSSW_ConfigFile = line.split('--python_filename')[1].split()[0].strip()

    if CMSSWVersion and CMSSW_ConfigFile:
        with open(config_file_path, 'a') as f:
            f.write(f"{script_name},{CMSSWVersion},{CMSSW_ConfigFile}\n")

def download_and_prepare_scripts(chain_dict: OrderedDict, args: argparse.Namespace):
    """Download and prepare scripts from the provided dictionary."""
    config_file_path = args.CMSSWConfigFile
    if os.path.exists(config_file_path):
        os.remove(config_file_path)

    for key, value in chain_dict.items():
        logging.info(f'Starting preparation for {key}')
        script_name = f"{key}.sh"
        if args.NOdownload:
            logging.info(f'Skipping download for {key}')
        else:
            download_script(value, script_name)
        modify_script(script_name)
        parse_script_for_config(script_name, config_file_path)

        if args.run_exec:
            run_subprocess(["./" + script_name], f'executing {script_name}')

        logging.info(f'Finished {key}')

def generate_executable_script(config_file: str, args: argparse.Namespace):
    """Generate an executable script from the configuration file."""
    logging.info(f"Generating executable script from {config_file}")
    cmssw_versions = {}
    cmssw_config_files = {}
    with open(config_file, 'r') as f:
        for line in f:
            if args.UseCustomNanoAOD:
                # Update the CMSSW version from CMSSW_10_6_26 to CMSSW_10_6_30
                line = line.replace('CMSSW_10_6_26', 'CMSSW_10_6_30')
            step, version, cmssw_config_file = line.strip().split(',')
            cmssw_versions[f"step{step.split('_')[0][-1]}"] = version
            cmssw_config_files[f"step{step.split('_')[0][-1]}"] = cmssw_config_file.split('/')[-1]

    script_content = build_bash_script(cmssw_versions, cmssw_config_files, args)
    with open(args.jobName + '.sh', 'w') as f:
        f.write(script_content)

def build_bash_script(versions: dict, config_files: dict, args: argparse.Namespace) -> str:
    """
    Constructs the bash script content based on the provided CMSSW versions and configuration files.
    """
    script_content = f"""#!/bin/bash

echo "Job started..."
echo "Starting job on " $(date)
echo "Running on: $(uname -a)"
echo "System software: $(cat /etc/redhat-release)"
source /cvmfs/cms.cern.ch/cmsset_default.sh
export SCRAM_ARCH=slc7_amd64_gcc700
echo "###################################################"
echo "#    List of Input Arguments: "
echo "###################################################"
echo "Input Arguments (Cluster ID): $1"
echo "Input Arguments (Proc ID): $2"
echo "Input Arguments (Output Dir): $3"
echo "Input Arguments (Gridpack with path): $4"
echo "Input Arguments (maxEvents): $5"
echo ""

# Setting up CMSSW versions and configuration files
"""

    # Adding CMSSW version and config file information
    for step, version in versions.items():
        config_file = config_files.get(step, "default_config.py")
        script_content += f"{step}={version}\n"
        script_content += f"{step}_cfg={config_file}\n"

    script_content += "\nseed=$(($1 + $2))\n\n"  # Seed value calculation

    # Loop through the steps and generate the script content
    for i in range(1, len(versions) + 1):
        step = f"step{i}"
        script_content += 'echo "###################################################"\n'
        script_content += f"echo \"Running {step}...\"\n"
        script_content += f"if [ -r ${{{step}}}/src ] ; then\n"
        script_content += f"    echo release ${{{step}}} already exists\n"
        script_content += f"else\n"
        script_content += f"    scram p CMSSW ${{{step}}}\n"
        script_content += f"fi\n"
        script_content += f"cd ${{{step}}}/src\n"
        script_content += f"eval `scram runtime -sh`\n"
        if args.UseCustomNanoAOD and step == 'step7': # FIXME: This is a temporary fix
            script_content += f"git cms-merge-topic -u ram1123:CMSSW_10_6_30_HHWWgg_nanoV9\n"
            script_content += f"./PhysicsTools/NanoTuples/scripts/install_onnxruntime.sh\n"
        script_content += f"scram b\n"
        script_content += f"cd -\n"
        if i == 1:
            # Special handling for step 1 with seed value
            script_content += f"cmsRun ${{{step}_cfg}} seedval=${{seed}} maxEvents=${{5}} gridpack=${{4}}\n"
        else:
            script_content += f"cmsRun ${{{step}_cfg}}\n"
        script_content += "echo \"list all files\"\n"
        script_content += "ls -ltrh\n"

    # copy output nanoAOD file to output directory with cluster ID and process ID as suffix of the root file
    script_content += "\n# Copy output nanoAOD file to output directory\n"
    script_content += "echo \"Copying output nanoAOD file to output directory\"\n"
    script_content += "ls -ltrh\n"
    script_content += "echo \"cp -r HIG-RunIISummer20UL17NanoAODv9-03735.root $3/nanoAOD_$1_$2.root\"\n"    # FIXME: Hardcoded nanoAOD output file name
    script_content += "cp -r HIG-RunIISummer20UL17NanoAODv9-03735.root $3/nanoAOD_$1_$2.root\n" # FIXME: Hardcoded nanoAOD output file name
    script_content += "echo \"Job finished on \" $(date)\n"

    return script_content

def generate_jdl_file(args: argparse.Namespace):
    """Generate the JDL file."""
    # Ensure the log directory exists
    log_dir = Path("log")
    log_dir.mkdir(exist_ok=True)

    # Prepare the comma-separated list of configuration files
    comma_separated_config_files = ''
    with open(args.CMSSWConfigFile, 'r') as f:
        comma_separated_config_files = ', '.join(line.split(',')[2].strip() for line in f)

    # Prepare paths and template replacements
    jdl_content = []
    logging.debug(f"Comma-separated config files: {comma_separated_config_files}")
    jdl_content.append(jdl_file_template_part1of2.format(
        CondorExecutable=os.path.abspath(args.jobName),
        CommaSeparatedConfigFiles=comma_separated_config_files,
        CondorQueue=args.queue
    ))

    # Loop through the models and generate specific JDL configurations
    for gridpack in models[args.model]:
        TimeStamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

        # For the naming convention grab sample info from gridpack path
        SampleName = gridpack.split('/')[-1]
        for key, value in ReplacementDict.items():
            # Update the SampleName using the replacement dict
            SampleName = SampleName.replace(key, value)

        model_log_dir = log_dir / args.model / SampleName / TimeStamp
        model_log_dir.mkdir(parents=True, exist_ok=True)

        output_dir = Path(args.outDir) / args.model / SampleName / TimeStamp
        output_dir.mkdir(parents=True, exist_ok=True)

        logging.debug(f"Log directory: {model_log_dir}")
        logging.debug(f"Output directory: {output_dir}")

        jdl_content.append(jdl_file_template_part2of2.format(
            CondorLogPath=str(model_log_dir),
            OutputDir=str(output_dir),
            GridpackWithPath=gridpack,
            maxEvents=args.nevents,
            Queue=args.nJobs
        ))
        if args.debug:
            break

    # Write the JDL content to a file
    jdl_filename = f"{args.jobName}.jdl"
    with open(jdl_filename, 'w') as jdl_file:
        jdl_file.write("\n".join(jdl_content))

    logging.info(f"JDL file '{jdl_filename}' has been generated.")


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='Script to automate CMSSW script processing')
    parser.add_argument('--nevents', type=int, default=100, help='Number of events to process')
    parser.add_argument('--run_exec', action='store_true', help='Run the executable script after creation')
    parser.add_argument('--NOdownload', action='store_true', help='Do not download the scripts')
    parser.add_argument('--CMSSWConfigFile', type=str, default='utils/CMSSWConfigFile.txt', help='Name of the CMSSW configuration file')
    parser.add_argument('--model', type=str, default='HHbbgg', help='Gridpack model from gridpack_lists.py')
    parser.add_argument('--queue', type=str, default='testmatch',choices=['espresso', 'microcentury', 'longlunch', 'workday', 'tomorrow', 'testmatch', 'nextweek'],  help='Condor queue to use')
    parser.add_argument('--outDir', type=str, help='Output directory', required=True)
    parser.add_argument('--nJobs', type=int, default=1, help='Number of jobs to submit with each gridpack')
    parser.add_argument('--jobName', type=str, default='run_simulation_HHbbgg', help='Job name')
    parser.add_argument('--UseCustomNanoAOD', action='store_true', help='Use custom nanoAOD file for analysis')
    parser.add_argument('--debug', action='store_true', help='Submit only one job for debugging')
    return parser.parse_args()

def printInfoToSubmit(args: argparse.Namespace):
    CondorExecutable = os.path.abspath(args.jobName)

    print("===> Set Proxy Using:")
    print("\033[92mvoms-proxy-init --voms cms --valid 168:00\033[0m")
    print("===> copy proxy to home path")
    print("\033[92mcp /tmp/x509up_u48539 ~/\033[0m")
    print("===> export the proxy")
    print("\033[92mexport X509_USER_PROXY=~/x509up_u48539\033[0m")
    print("===> Submit jobs using:")
    print(f"\033[92mcondor_submit {CondorExecutable}.jdl\033[0m")

def main():
    """Main function."""
    args = parse_arguments()

    logging.info(f"Processing with the following parameters: {args}")

    if not args.NOdownload:
        # FIXME: Place the generated config files to appropriate directory ConfigFiles/HHTobbgg/Summer20UL17/
        # FIXME: Improve this function and the working of `NOdownload` flag
        # INFO: Users may need to modify the generated .sh file or the configuration file
        download_and_prepare_scripts(ChainDownloadLinkFromMccM_dict, args)
    generate_executable_script(args.CMSSWConfigFile, args)  # FIXME: Hardcoded file name
    generate_jdl_file(args)
    printInfoToSubmit(args)

    logging.info("Script processing completed.")

if __name__ == "__main__":
    main()
